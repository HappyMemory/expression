Q1:先写代码还是先写单元测试？
	编码前，要先写测试，很多没有写过单元测试的朋友会想，代码都没有，连测试的对象都没有，我怎么写单元测试？
	1. 我们可以通过先画流程图，写伪代码或者建模来解决这个问题，这样让我们站在用户的角色去开发，尽早的发现问题
	2. 避免我们开发完了，某个功能模块遗漏了的情况。
	3. 这样开发出来的程序扩展性、维护性很容易理解。

Q2:谁来编写单元测试？
   单元测试一般由开发员自己来写，但是我们自己对自己的代码编写单元测试的情况下，习惯性的往理想情况下编写，开发员
   最好不要针对自己的代码编写单元测试。应该有其他的开发编写，这样减少了bug 也提高了开发的水平。

Q3:如何避免无用的测试？
   1.只写必要的测试
     编写自己觉得不靠谱的代码，例如业务很复杂自己没有吃透，以前没有写过，感觉会产生无法预料的结果
   2.只写关键的测试
     有时候必要的测试我们写不出来，也没有人知道，我么只能勉强跳过。但是关键性的测试不能跳过，关键性测试就是：你写的代码的核心逻辑。如果你不知道怎么处理，你知道要保证最终要的那条路线是可以走通的，将来重构的时候，这条路线能确保你不会茫然。
   3.无用的测试
      3.1 不要去测试开发语言的标准库和核心库,因为这些代码都是久经考验过得。虽然这些会出现小概率的错误。（如果你确定是开发语言的标准库或者核心库的问题，你应该测试标准库和核心库，因为它们都带有完整的测试用例）
      3.2 不要去测试基础框架和工具方法和外部依赖的有效性,当你遇到这种问题，你应该打桩"mock"。
      3.3 你只见过它测试通过，没有见过它测试失败，可能这种测试从头到尾都没测试任何代码，我们应该手动破坏代码，以确保真的覆盖到了目标代码。

 Q4:测试代码覆盖率
 	我们应该忽略代码覆盖率：就算覆盖率达到100%，和"靠谱"的代码肯能有天壤之别，问题就在于有些公司把代码覆盖率作为考核的标准，这就让开发很容易就演变成"追求100%代码覆盖率"，然后无所不用，连开发都不懂，那就更悲剧了，一群人对着水分极大的代码，然后对着"100%代码覆盖率"乐得合不弄嘴，想想都难受想哭。

 Q5：测试中的仿件"mock"或者我们说的打桩？
    有时候对被测试的系统进行测试很困难，因为它依赖无法在测试环境中使用的对象、组件、API或者它们不可用。在这种情况下，我们确保测试系统的内部行为有更多的控制性和可见性，我们可以使用仿件"mock"或者打桩。
    什么情况下使用"仿件mock、桩件stubs" ?
        1. 外部依赖不存在。
        2. 外部依赖不会返回测试需要的结果，或者它有不良的副作用。
        3. 如果外部依赖更变，会导致我们的测试失败。
   我们来看一个打桩示例：
        1. 我们在编写单元测试购物车"Cart"类，依赖产品类"Product"和用户类"User"。
        2. 依赖产品类"Product"和用户类"User"已经测试过了。
        3. 依赖的产品类"Product"和用户类"User"是由他人开发的。
    示例问题：
        1. 产品类"Product"和用户类"User"一旦出现问题，不会让我们误以为购物车类"Cart"出了问题。
        2. 不用为了创造很多前置条件，才能做出断言。（如果这样你应该把它放到集成测试）。
        3. 在测试购物车时，我们应该避免使用"new Cart($userId, $productId, $quantity)"这种方式，这样会出现程序中很多地方都去做了重复的查询，并且影响程序的执行效率，更不利于打桩，我们应该使用这种方式"new Cart(User $user, Product $product, $quantity)"

Q6:极限编程 xp 　
	讲究TDD，即测试驱动开发，先写测试代码，再进行开发。在实际的工作中，可以不必过分强调先什么后什么，重要的是高效和感觉舒适。
	从经验来看，先编写产品函数的框架，然后编写测试函数，针对产品函数的功能编写测试用例，然后编写产品函数的代码，每写一个功能点都进行测试，随时补充测试用例。
	所谓先编写产品函数的框架，是指先编写函数空的实现，有返回值的直接返回一个合适值，编译通过后在编写测试代码，这时，函数名，参数表，返回类型都应该确定下来了，所编写的测试代码以后需修改的可能性比较小。

Q7: 到底要测试什么？
    大都是在编写业务功能，而且大多数是基于数据库的系统开发。这是我们实施php的单元测试最大的难点所在。需要整合phpunit 的dbunit测试，也就是一开始就得学习dbunit的知识。

Q8：TDD：测试驱动开发
　　　最大的好处之一就是：你可以重构程序获得更好的设计或者只需改变某个项目的名称。。。只要这种设计没有破坏测试，前提是你有100%的信心保证你的改变没有破坏任何东西。

Q9: 